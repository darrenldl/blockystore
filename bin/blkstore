#!/usr/bin/env python3
import argparse
import shutil
import ipaddress
from packaging import version
import re
import subprocess
from subprocess import Popen, PIPE
import socket
import threading
import json

blkar_name="blkar"
blkar_min_ver=version.parse("7.0.0")
blkar_max_ver_exc=version.parse("8.0.0")

default_port=20000

rs_data = 10
rs_parity = 2
burst = 10

data_chunk = 4096 - 16

def check_for_blkar_installation():
    if shutil.which(blkar_name) == None:
        print(blkar_name + " not detected, please make sure you have installed blkar correctly")
        exit(1)

    ver_str = re.match("blkar (.*)\n", subprocess.check_output(["blkar", "--version"]).decode("utf-8")).group(1)
    ver = version.parse(ver_str)
    if ver < blkar_min_ver or ver >= blkar_max_ver_exc:
        print("Version " + ver_str + " not supported, version must be >=" + blkar_min_ver + " && < " + blkar_max_ver_exc)
        exit(1)

class Encoder:
    def __init__(self, file_path : str):
        self.proc = Popen(["blkar", "encode",
                           "--sbx-version", "19",
                           "--rs-data", str(rs_data),
                           "--rs-parity", str(rs_parity),
                           "--burst", str(burst),
                           "--json",
                           "-",
                           file_path],
                          stdin=PIPE,
                          stdout=PIPE)

    def encode(self, input : bytes):
        self.proc.stdin.write(input)

    def close(self):
        self.proc.stdin.close()

class Decoder:
    def __init__(self, file_path : str):
        self.proc = Popen(["blkar", "decode",
                           "--json",
                           file_path,
                           "-"],
                          stdin=PIPE,
                          stdout=PIPE)

    def decode(self):
        return self.proc.stdout.read(data_chunk)

    def close(self):
        self.proc.terminate()

class ClientRequest:
    def __init__(self):
        self.op = None
        self.file_name = None

    def from_file(self, file):
        msg = json.loads(file.readline())

        self.op = msg["op"]
        if self.op != "upload" and self.op != "download":
            raise ValueError("Invalid op from client")
        self.file_name = msg["file_name"]

class SingleClientServer:
    def __init__(self, stop_ev, conn, addr):
        self.conn = conn
        self.file = conn.makefile(mode='rb')
        self.addr = addr
        self.stop_ev = stop_ev
        self.encoder = None
        self.decoder = None

        thread = threading.Thread(target=self.run, args=())
        thread.start()

    def core(self):
        print("Serving ", self.addr)

        try:
            # read request
            client_req = ClientRequest()
            client_req.from_file(self.file)

            if client_req.op == "upload":
                print("Client requested to upload")
                self.encoder = Encoder(client_req.file_name)
                while True:
                    data = self.file.read(1024)
                    if not data:
                        break
                    self.encoder.encode(data)
            else:
                print("Client requested to download")
                decoder = Decoder(client_req.file_name)
        except json.decoder.JSONDecodeError:
            print("Invalid config sent from client")
        except KeyError:
            print("Invalid config sent from client")
        except KeyboardInterrupt:
            print("Interrupted")
        except ValueError as e:
            print(e)
        finally:
            self.clean_up()

    def clean_up(self):
        self.file.close()
        self.conn.close()
        if self.encoder is not None:
            self.encoder.close()
        if self.decoder is not None:
            self.decoder.close()

    def run(self):
        self.core()
        self.clean_up()

def serve(args):
    stop_ev = threading.Event()
    addr = "127.0.0.1"
    port = args.p
    check_for_blkar_installation()
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind((addr, port))
            s.listen()
            while True:
                conn, addr = s.accept()
                SingleClientServer(stop_ev, conn, addr)
    except KeyboardInterrupt:
        print("Interrupted")

def upload(args):
    return None

def download(args):
    return None

def print_please_specify_subcommand(args):
    print("Invoke with -h or --help for help message")

def main():
    check_for_blkar_installation()
    parser = argparse.ArgumentParser()
    parser.set_defaults(func=print_please_specify_subcommand)
    subparsers = parser.add_subparsers(help="subcommand help")

    parser_serve = subparsers.add_parser("serve", help="Launch in server mode")
    parser_serve.add_argument("-p", metavar="PORT", default=default_port, type=int, help="Localhost port to listen on, defaults to " + str(default_port))
    parser_serve.add_argument("dir", help="Directory for file storage")
    parser_serve.set_defaults(func=serve)

    parser_upload = subparsers.add_parser("upload", help="Upload file to server")
    parser_upload.add_argument("addr", type=ipaddress.ip_address, help="Address to connect to")
    parser_upload.add_argument("-p", metavar="PORT", default=default_port, type=int, help="Port to connect to, defaults to " + str(default_port))
    parser_upload.set_defaults(func=upload)

    parser_download = subparsers.add_parser("download", help="Download file from server")
    parser_download.add_argument("addr", type=ipaddress.ip_address, help="Address to connect to")
    parser_download.add_argument("-p", metavar="PORT", default=default_port, type=int, help="Port to connect to, defaults to " + str(default_port))
    parser_download.set_defaults(func=download)

    args = parser.parse_args()
    args.func(args)

if __name__ == "__main__":
    main()
